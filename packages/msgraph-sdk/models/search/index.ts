/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
import { deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, DevicePlatformType, DevicePlatformTypeObject, serializeBaseCollectionPaginationCountResponse, serializeEntity, type BaseCollectionPaginationCountResponse, type Entity } from '../';
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface Acronym extends Parsable, SearchAnswer {
    /**
     * The standsFor property
     */
    standsFor?: string;
    /**
     * The state property
     */
    state?: AnswerState;
}
export interface AcronymCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Acronym[];
}
export interface AnswerKeyword extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The keywords property
     */
    keywords?: string[];
    /**
     * The matchSimilarKeywords property
     */
    matchSimilarKeywords?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The reservedKeywords property
     */
    reservedKeywords?: string[];
}
export type AnswerState = (typeof AnswerStateObject)[keyof typeof AnswerStateObject];
export interface AnswerVariant extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The description property
     */
    description?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The languageTag property
     */
    languageTag?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The platform property
     */
    platform?: DevicePlatformType;
    /**
     * The webUrl property
     */
    webUrl?: string;
}
export interface Bookmark extends Parsable, SearchAnswer {
    /**
     * The availabilityEndDateTime property
     */
    availabilityEndDateTime?: Date;
    /**
     * The availabilityStartDateTime property
     */
    availabilityStartDateTime?: Date;
    /**
     * The categories property
     */
    categories?: string[];
    /**
     * The groupIds property
     */
    groupIds?: string[];
    /**
     * The isSuggested property
     */
    isSuggested?: boolean;
    /**
     * The keywords property
     */
    keywords?: AnswerKeyword;
    /**
     * The languageTags property
     */
    languageTags?: string[];
    /**
     * The platforms property
     */
    platforms?: DevicePlatformType[];
    /**
     * The powerAppIds property
     */
    powerAppIds?: string[];
    /**
     * The state property
     */
    state?: AnswerState;
    /**
     * The targetedVariations property
     */
    targetedVariations?: AnswerVariant[];
}
export interface BookmarkCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Bookmark[];
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AcronymCollectionResponse}
 */
export function createAcronymCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAcronymCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Acronym}
 */
export function createAcronymFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAcronym;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnswerKeyword}
 */
export function createAnswerKeywordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnswerKeyword;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnswerVariant}
 */
export function createAnswerVariantFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnswerVariant;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BookmarkCollectionResponse}
 */
export function createBookmarkCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBookmarkCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Bookmark}
 */
export function createBookmarkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBookmark;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Identity}
 */
export function createIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IdentitySet}
 */
export function createIdentitySetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIdentitySet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {QnaCollectionResponse}
 */
export function createQnaCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQnaCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Qna}
 */
export function createQnaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQna;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SearchAnswer}
 */
export function createSearchAnswerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.search.acronym":
                    return deserializeIntoAcronym;
                case "#microsoft.graph.search.bookmark":
                    return deserializeIntoBookmark;
                case "#microsoft.graph.search.qna":
                    return deserializeIntoQna;
            }
        }
    }
    return deserializeIntoSearchAnswer;
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAcronym(acronym: Partial<Acronym> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSearchAnswer(acronym),
        "standsFor": n => { acronym.standsFor = n.getStringValue(); },
        "state": n => { acronym.state = n.getEnumValue<AnswerState>(AnswerStateObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAcronymCollectionResponse(acronymCollectionResponse: Partial<AcronymCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(acronymCollectionResponse),
        "value": n => { acronymCollectionResponse.value = n.getCollectionOfObjectValues<Acronym>(createAcronymFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnswerKeyword(answerKeyword: Partial<AnswerKeyword> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { answerKeyword.backingStoreEnabled = true; },
        "keywords": n => { answerKeyword.keywords = n.getCollectionOfPrimitiveValues<string>(); },
        "matchSimilarKeywords": n => { answerKeyword.matchSimilarKeywords = n.getBooleanValue(); },
        "@odata.type": n => { answerKeyword.odataType = n.getStringValue(); },
        "reservedKeywords": n => { answerKeyword.reservedKeywords = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnswerVariant(answerVariant: Partial<AnswerVariant> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { answerVariant.backingStoreEnabled = true; },
        "description": n => { answerVariant.description = n.getStringValue(); },
        "displayName": n => { answerVariant.displayName = n.getStringValue(); },
        "languageTag": n => { answerVariant.languageTag = n.getStringValue(); },
        "@odata.type": n => { answerVariant.odataType = n.getStringValue(); },
        "platform": n => { answerVariant.platform = n.getEnumValue<DevicePlatformType>(DevicePlatformTypeObject); },
        "webUrl": n => { answerVariant.webUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoBookmark(bookmark: Partial<Bookmark> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSearchAnswer(bookmark),
        "availabilityEndDateTime": n => { bookmark.availabilityEndDateTime = n.getDateValue(); },
        "availabilityStartDateTime": n => { bookmark.availabilityStartDateTime = n.getDateValue(); },
        "categories": n => { bookmark.categories = n.getCollectionOfPrimitiveValues<string>(); },
        "groupIds": n => { bookmark.groupIds = n.getCollectionOfPrimitiveValues<string>(); },
        "isSuggested": n => { bookmark.isSuggested = n.getBooleanValue(); },
        "keywords": n => { bookmark.keywords = n.getObjectValue<AnswerKeyword>(createAnswerKeywordFromDiscriminatorValue); },
        "languageTags": n => { bookmark.languageTags = n.getCollectionOfPrimitiveValues<string>(); },
        "platforms": n => { bookmark.platforms = n.getCollectionOfEnumValues<DevicePlatformType>(DevicePlatformTypeObject); },
        "powerAppIds": n => { bookmark.powerAppIds = n.getCollectionOfPrimitiveValues<string>(); },
        "state": n => { bookmark.state = n.getEnumValue<AnswerState>(AnswerStateObject); },
        "targetedVariations": n => { bookmark.targetedVariations = n.getCollectionOfObjectValues<AnswerVariant>(createAnswerVariantFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoBookmarkCollectionResponse(bookmarkCollectionResponse: Partial<BookmarkCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(bookmarkCollectionResponse),
        "value": n => { bookmarkCollectionResponse.value = n.getCollectionOfObjectValues<Bookmark>(createBookmarkFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIdentity(identity: Partial<Identity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { identity.backingStoreEnabled = true; },
        "displayName": n => { identity.displayName = n.getStringValue(); },
        "id": n => { identity.id = n.getStringValue(); },
        "@odata.type": n => { identity.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIdentitySet(identitySet: Partial<IdentitySet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "application": n => { identitySet.application = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "backingStoreEnabled": n => { identitySet.backingStoreEnabled = true; },
        "device": n => { identitySet.device = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "@odata.type": n => { identitySet.odataType = n.getStringValue(); },
        "user": n => { identitySet.user = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoQna(qna: Partial<Qna> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSearchAnswer(qna),
        "availabilityEndDateTime": n => { qna.availabilityEndDateTime = n.getDateValue(); },
        "availabilityStartDateTime": n => { qna.availabilityStartDateTime = n.getDateValue(); },
        "groupIds": n => { qna.groupIds = n.getCollectionOfPrimitiveValues<string>(); },
        "isSuggested": n => { qna.isSuggested = n.getBooleanValue(); },
        "keywords": n => { qna.keywords = n.getObjectValue<AnswerKeyword>(createAnswerKeywordFromDiscriminatorValue); },
        "languageTags": n => { qna.languageTags = n.getCollectionOfPrimitiveValues<string>(); },
        "platforms": n => { qna.platforms = n.getCollectionOfEnumValues<DevicePlatformType>(DevicePlatformTypeObject); },
        "state": n => { qna.state = n.getEnumValue<AnswerState>(AnswerStateObject); },
        "targetedVariations": n => { qna.targetedVariations = n.getCollectionOfObjectValues<AnswerVariant>(createAnswerVariantFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoQnaCollectionResponse(qnaCollectionResponse: Partial<QnaCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(qnaCollectionResponse),
        "value": n => { qnaCollectionResponse.value = n.getCollectionOfObjectValues<Qna>(createQnaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSearchAnswer(searchAnswer: Partial<SearchAnswer> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(searchAnswer),
        "description": n => { searchAnswer.description = n.getStringValue(); },
        "displayName": n => { searchAnswer.displayName = n.getStringValue(); },
        "lastModifiedBy": n => { searchAnswer.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { searchAnswer.lastModifiedDateTime = n.getDateValue(); },
        "webUrl": n => { searchAnswer.webUrl = n.getStringValue(); },
    }
}
export interface Identity extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The id property
     */
    id?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface IdentitySet extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The application property
     */
    application?: Identity;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The device property
     */
    device?: Identity;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The user property
     */
    user?: Identity;
}
export interface Qna extends Parsable, SearchAnswer {
    /**
     * The availabilityEndDateTime property
     */
    availabilityEndDateTime?: Date;
    /**
     * The availabilityStartDateTime property
     */
    availabilityStartDateTime?: Date;
    /**
     * The groupIds property
     */
    groupIds?: string[];
    /**
     * The isSuggested property
     */
    isSuggested?: boolean;
    /**
     * The keywords property
     */
    keywords?: AnswerKeyword;
    /**
     * The languageTags property
     */
    languageTags?: string[];
    /**
     * The platforms property
     */
    platforms?: DevicePlatformType[];
    /**
     * The state property
     */
    state?: AnswerState;
    /**
     * The targetedVariations property
     */
    targetedVariations?: AnswerVariant[];
}
export interface QnaCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Qna[];
}
export interface SearchAnswer extends Entity, Parsable {
    /**
     * The description property
     */
    description?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The lastModifiedBy property
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The lastModifiedDateTime property
     */
    lastModifiedDateTime?: Date;
    /**
     * The webUrl property
     */
    webUrl?: string;
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAcronym(writer: SerializationWriter, acronym: Partial<Acronym> | undefined = {}) : void {
    serializeSearchAnswer(writer, acronym)
    writer.writeStringValue("standsFor", acronym.standsFor);
    writer.writeEnumValue<AnswerState>("state", acronym.state);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAcronymCollectionResponse(writer: SerializationWriter, acronymCollectionResponse: Partial<AcronymCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, acronymCollectionResponse)
    writer.writeCollectionOfObjectValues<Acronym>("value", acronymCollectionResponse.value, serializeAcronym);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnswerKeyword(writer: SerializationWriter, answerKeyword: Partial<AnswerKeyword> | undefined = {}) : void {
    writer.writeCollectionOfPrimitiveValues<string>("keywords", answerKeyword.keywords);
    writer.writeBooleanValue("matchSimilarKeywords", answerKeyword.matchSimilarKeywords);
    writer.writeStringValue("@odata.type", answerKeyword.odataType);
    writer.writeCollectionOfPrimitiveValues<string>("reservedKeywords", answerKeyword.reservedKeywords);
    writer.writeAdditionalData(answerKeyword.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnswerVariant(writer: SerializationWriter, answerVariant: Partial<AnswerVariant> | undefined = {}) : void {
    writer.writeStringValue("description", answerVariant.description);
    writer.writeStringValue("displayName", answerVariant.displayName);
    writer.writeStringValue("languageTag", answerVariant.languageTag);
    writer.writeStringValue("@odata.type", answerVariant.odataType);
    writer.writeEnumValue<DevicePlatformType>("platform", answerVariant.platform);
    writer.writeStringValue("webUrl", answerVariant.webUrl);
    writer.writeAdditionalData(answerVariant.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeBookmark(writer: SerializationWriter, bookmark: Partial<Bookmark> | undefined = {}) : void {
    serializeSearchAnswer(writer, bookmark)
    writer.writeDateValue("availabilityEndDateTime", bookmark.availabilityEndDateTime);
    writer.writeDateValue("availabilityStartDateTime", bookmark.availabilityStartDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("categories", bookmark.categories);
    writer.writeCollectionOfPrimitiveValues<string>("groupIds", bookmark.groupIds);
    writer.writeBooleanValue("isSuggested", bookmark.isSuggested);
    writer.writeObjectValue<AnswerKeyword>("keywords", bookmark.keywords, serializeAnswerKeyword);
    writer.writeCollectionOfPrimitiveValues<string>("languageTags", bookmark.languageTags);
    if(bookmark.platforms)
    writer.writeEnumValue<DevicePlatformType>("platforms", ...bookmark.platforms);
    writer.writeCollectionOfPrimitiveValues<string>("powerAppIds", bookmark.powerAppIds);
    writer.writeEnumValue<AnswerState>("state", bookmark.state);
    writer.writeCollectionOfObjectValues<AnswerVariant>("targetedVariations", bookmark.targetedVariations, serializeAnswerVariant);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeBookmarkCollectionResponse(writer: SerializationWriter, bookmarkCollectionResponse: Partial<BookmarkCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, bookmarkCollectionResponse)
    writer.writeCollectionOfObjectValues<Bookmark>("value", bookmarkCollectionResponse.value, serializeBookmark);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIdentity(writer: SerializationWriter, identity: Partial<Identity> | undefined = {}) : void {
    writer.writeStringValue("displayName", identity.displayName);
    writer.writeStringValue("id", identity.id);
    writer.writeStringValue("@odata.type", identity.odataType);
    writer.writeAdditionalData(identity.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIdentitySet(writer: SerializationWriter, identitySet: Partial<IdentitySet> | undefined = {}) : void {
    writer.writeObjectValue<Identity>("application", identitySet.application, serializeIdentity);
    writer.writeObjectValue<Identity>("device", identitySet.device, serializeIdentity);
    writer.writeStringValue("@odata.type", identitySet.odataType);
    writer.writeObjectValue<Identity>("user", identitySet.user, serializeIdentity);
    writer.writeAdditionalData(identitySet.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeQna(writer: SerializationWriter, qna: Partial<Qna> | undefined = {}) : void {
    serializeSearchAnswer(writer, qna)
    writer.writeDateValue("availabilityEndDateTime", qna.availabilityEndDateTime);
    writer.writeDateValue("availabilityStartDateTime", qna.availabilityStartDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("groupIds", qna.groupIds);
    writer.writeBooleanValue("isSuggested", qna.isSuggested);
    writer.writeObjectValue<AnswerKeyword>("keywords", qna.keywords, serializeAnswerKeyword);
    writer.writeCollectionOfPrimitiveValues<string>("languageTags", qna.languageTags);
    if(qna.platforms)
    writer.writeEnumValue<DevicePlatformType>("platforms", ...qna.platforms);
    writer.writeEnumValue<AnswerState>("state", qna.state);
    writer.writeCollectionOfObjectValues<AnswerVariant>("targetedVariations", qna.targetedVariations, serializeAnswerVariant);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeQnaCollectionResponse(writer: SerializationWriter, qnaCollectionResponse: Partial<QnaCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, qnaCollectionResponse)
    writer.writeCollectionOfObjectValues<Qna>("value", qnaCollectionResponse.value, serializeQna);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSearchAnswer(writer: SerializationWriter, searchAnswer: Partial<SearchAnswer> | undefined = {}) : void {
    serializeEntity(writer, searchAnswer)
    writer.writeStringValue("description", searchAnswer.description);
    writer.writeStringValue("displayName", searchAnswer.displayName);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", searchAnswer.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", searchAnswer.lastModifiedDateTime);
    writer.writeStringValue("webUrl", searchAnswer.webUrl);
}
export const AnswerStateObject = {
    Published: "published",
    Draft: "draft",
    Excluded: "excluded",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
